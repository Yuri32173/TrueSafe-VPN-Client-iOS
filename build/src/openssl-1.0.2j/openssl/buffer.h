#ifndef HEADER_BUFFER_H
#define HEADER_BUFFER_H

#include <openssl/ossl_typ.h>

#include <cstddef>
#include <memory>
#include <string>

/* Already declared in ossl_typ.h */
/* typedef struct buf_mem_st BUF_MEM; */

struct buf_mem_st {
    size_t length;              /* current number of bytes */
    char *data;
    size_t max;                 /* size of buffer */
};

class BUF_MEM {
public:
    BUF_MEM() : buf_{nullptr}, length_{0}, max_{0} {}

    BUF_MEM(const BUF_MEM &) = delete;
    BUF_MEM(BUF_MEM &&) = delete;
    BUF_MEM &operator=(const BUF_MEM &) = delete;
    BUF_MEM &operator=(BUF_MEM &&) = delete;

    ~BUF_MEM() {
        if (buf_ != nullptr) {
            ::OPENSSL_free(buf_);
            buf_ = nullptr;
        }
    }

    char *data() const {
        return buf_;
    }

    size_t length() const {
        return length_;
    }

    size_t max() const {
        return max_;
    }

    bool grow(size_t len) {
        if (len <= max_) {
            length_ = len;
            return true;
        }

        char *new_buf = static_cast<char *>(::OPENSSL_realloc(buf_, len));
        if (new_buf == nullptr) {
            return false;
        }

        buf_ = new_buf;
        max_ = len;
        length_ = len;
        return true;
    }

    bool grow_clean(size_t len) {
        if (!grow(len)) {
            return false;
        }

        ::memset(buf_, 0, length_);
        return true;
    }

private:
    char *buf_;
    size_t length_;
    size_t max_;
};

size_t BUF_strnlen(const char *str, size_t maxlen);
std::unique_ptr<char[]> BUF_strdup(const char *str);

/*
 * Like strndup, but in addition, explicitly guarantees to never read past the
 * first |siz| bytes of |str|.
 */
std::unique_ptr<char[]> BUF_strndup(const char *str, size_t siz);

std::unique_ptr<void, decltype(&::OPENSSL_free)> BUF_memdup(const void *data, size_t siz);
void BUF_reverse(unsigned char *out, const unsigned char *in, size_t siz);

/* safe string functions */
size_t BUF_strlcpy(char *dst, const char *src, size_t siz);
size_t BUF_strlcat(char *dst, const char *src, size_t siz);

/* BEGIN ERROR CODES */
/*
 * The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_BUF_strings(void);

/* Error codes for the BUF functions. */

/* Function codes. */
# define BUF_F_BUF_MEMDUP                                 103
# define BUF_F_BUF_MEM_GROW                               100
# define BUF_F_BUF_MEM_GROW_CLEAN                         105
# define BUF_F_BUF_MEM_NEW                                101
# define BUF_F_BUF_STRDUP                                 102
# define BUF_F_BUF_STRNDUP                                104

/* Reason codes. */

#endif  // HEADER_BUFFER_H
